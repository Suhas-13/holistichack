================================================================================
REAL-TIME GRAPH VISUALIZATION - DATA STRUCTURES ARCHITECTURE
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                         WEBSOCKET EVENT STREAM                               │
│  cluster_add │ node_add │ node_update │ evolution_link_add                  │
└──────────────┬──────────────────────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         EVENT BATCH PROCESSOR                                │
│  • Queues events                                                             │
│  • Flushes every 100ms                                                       │
│  • Reduces re-renders                                                        │
└──────────────┬──────────────────────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         EVENT HANDLERS                                       │
│                                                                              │
│  handleClusterAdd()      O(C)   → Update clusters Map                       │
│  handleNodeAdd()         O(N+P) → Update nodes, indices, layout             │
│  handleNodeUpdate()      O(N)   → Merge updates, update stats               │
│  handleEvolutionLinkAdd() O(L+S) → Update links, indices                    │
│                                                                              │
└──────────────┬──────────────────────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         GRAPH STATE (Map-based)                              │
│                                                                              │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐          │
│  │ CORE DATA        │  │ INDICES          │  │ LAYOUT           │          │
│  │                  │  │                  │  │                  │          │
│  │ nodes: Map       │  │ nodesByCluster   │  │ layout: Map      │          │
│  │ clusters: Map    │  │ nodesByParent    │  │                  │          │
│  │ links: Map       │  │ linksBySource    │  │ position: {x,y}  │          │
│  │                  │  │ linksByTarget    │  │ velocity: {x,y}  │          │
│  │ O(1) lookups     │  │                  │  │ radius: number   │          │
│  │ Immutable        │  │ O(1) queries     │  │ Mutable          │          │
│  └──────────────────┘  └──────────────────┘  └──────────────────┘          │
│                                                                              │
└──────────────┬──────────────────────────────────────────────────────────────┘
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
┌─────────────────┐ ┌─────────────────────────────────────────────────────────┐
│ QUERY LAYER     │ │           VISUALIZATION LAYER                           │
│                 │ │                                                         │
│ getNodeDetail() │ │  ┌──────────────────┐  ┌──────────────────┐            │
│ queryNodes()    │ │  │ D3-FORCE PHYSICS │  │ REACT FLOW UI    │            │
│ calculateStats()│ │  │                  │  │                  │            │
│ getClusterNodes│ │  │ Force simulation │  │ Node rendering   │            │
│                 │ │  │ Layout calc      │  │ Edge rendering   │            │
│ O(1) to O(N)    │ │  │ 60 FPS updates   │  │ Zoom/Pan         │            │
│                 │ │  │                  │  │ Selection        │            │
└─────────────────┘ │  │ Runs in RAF      │  │ Memoized         │            │
                    │  └──────────────────┘  └──────────────────┘            │
                    │                                                         │
                    └─────────────────────────────────────────────────────────┘

================================================================================
DATA FLOW FOR "node_add" EVENT
================================================================================

WebSocket Event:
{
  "type": "node_add",
  "data": {
    "node_id": "node_eagle_1",
    "cluster_id": "eagle",
    "parent_ids": [],
    "attack_type": "base64_encoding",
    "status": "in_progress"
  }
}
    │
    ▼
handleNodeAdd(state, event):
    │
    ├─→ 1. Create GraphNode object
    ├─→ 2. Calculate initial position (near cluster center)
    ├─→ 3. Create NodeLayout object
    ├─→ 4. Clone state.nodes Map → add node
    ├─→ 5. Clone state.layout Map → add layout
    ├─→ 6. Update nodesByCluster index
    ├─→ 7. Update nodesByParent index (for each parent)
    ├─→ 8. Update cluster stats (total_attacks++)
    └─→ 9. Return new immutable state
    │
    ▼
React re-renders:
    │
    ├─→ GraphVisualization component
    ├─→ NodeLayer component
    ├─→ New AttackNode component (memoized)
    └─→ D3 force simulation adds node, reheats (alpha = 0.3)
    │
    ▼
60 FPS physics loop updates positions → debounced state update → smooth render

================================================================================
PERFORMANCE OPTIMIZATIONS
================================================================================

┌────────────────────────────────────────────────────────────────────────────┐
│  OPTIMIZATION          │ TECHNIQUE                │ IMPACT                 │
├────────────────────────┼──────────────────────────┼────────────────────────┤
│ Fast Lookups           │ Map instead of Array     │ O(1) vs O(n)          │
│ Efficient Queries      │ Multiple indices         │ 50-100x faster        │
│ Smooth Updates         │ Batch events (100ms)     │ 10 re-renders/sec     │
│ Prevent Re-renders     │ React.memo               │ 80-90% reduction      │
│ Viewport Culling       │ Only render visible      │ 50-70% faster         │
│ Level of Detail        │ Zoom-based rendering     │ 60 FPS at all zooms   │
│ Debounced Layout       │ 16ms throttle            │ Max 60 FPS updates    │
│ Separation of Concerns │ Layout separate from data│ Avoid cascade updates │
│ WebWorker Physics      │ Off main thread          │ No UI jank            │
└────────────────────────────────────────────────────────────────────────────┘

================================================================================
COMPLEXITY ANALYSIS (for 200-300 nodes)
================================================================================

┌────────────────────────────────────────────────────────────────────────────┐
│  OPERATION             │ COMPLEXITY   │ TIME (200 nodes) │ TIME (300 nodes)│
├────────────────────────┼──────────────┼──────────────────┼─────────────────┤
│ Add cluster            │ O(C)         │ < 0.1ms          │ < 0.1ms         │
│ Add node               │ O(N + P)     │ 1-2ms            │ 2-3ms           │
│ Update node            │ O(N)         │ 1-2ms            │ 2-3ms           │
│ Add link               │ O(L + S)     │ 1-2ms            │ 2-3ms           │
│ Get node by ID         │ O(1)         │ < 0.01ms         │ < 0.01ms        │
│ Get node children      │ O(1) + O(C)  │ < 0.1ms          │ < 0.1ms         │
│ Get cluster nodes      │ O(1) + O(M)  │ 0.1-0.5ms        │ 0.2-0.8ms       │
│ Query with filters     │ O(N)         │ 0.5-1ms          │ 1-2ms           │
│ Calculate statistics   │ O(N * D)     │ 1-2ms            │ 2-4ms           │
│ Render frame (SVG)     │ O(N + L)     │ 16ms (60 FPS)    │ 16-18ms (55 FPS)│
└────────────────────────────────────────────────────────────────────────────┘

D = max depth (typically 5-10)
C = children count (typically < 5)
M = cluster size (typically 30-50)

================================================================================
MEMORY USAGE (estimated for 300 nodes)
================================================================================

Core Data:
  nodes Map:           300 × 500 bytes  = 150 KB
  clusters Map:        7 × 200 bytes    = 1.4 KB
  links Map:           400 × 300 bytes  = 120 KB
  
Indices:
  nodesByCluster:      7 × (50 ids)     = 3 KB
  nodesByParent:       300 × (2 ids)    = 5 KB
  linksBySource:       300 × (2 ids)    = 5 KB
  linksByTarget:       300 × (1 id)     = 2 KB
  
Layout:
  layout Map:          300 × 100 bytes  = 30 KB
  
Total:                                  ≈ 320 KB
React overhead:                         ≈ 10 MB
D3 simulation:                          ≈ 5 MB
  
TOTAL MEMORY:                           ≈ 15-20 MB

================================================================================
RECOMMENDED STACK
================================================================================

┌────────────────────────────────────────────────────────────────────────────┐
│  LAYER              │ TECHNOLOGY          │ PURPOSE                         │
├─────────────────────┼─────────────────────┼─────────────────────────────────┤
│ Frontend Framework  │ React + TypeScript  │ UI components, state management │
│ State Management    │ useReducer + Maps   │ Immutable state updates         │
│ Rendering           │ React Flow          │ Graph UI, zoom/pan, selection   │
│ Physics/Layout      │ D3-Force            │ Force-directed layout           │
│ Real-time Updates   │ WebSocket           │ Server → client events          │
│ Styling             │ Tailwind CSS        │ Utility-first styling           │
│ Animations          │ Framer Motion       │ Smooth transitions              │
└────────────────────────────────────────────────────────────────────────────┘

================================================================================
FILES DELIVERED
================================================================================

1. graph-data-structures.ts (320 lines)
   • All TypeScript interfaces
   • Enums (NodeStatus, AttackType, EvolutionType)
   • GraphState, GraphNode, GraphCluster, EvolutionLink
   • WebSocket event types
   • Layout configuration

2. graph-state-management.ts (450 lines)
   • State initialization
   • Event handlers (cluster_add, node_add, node_update, link_add)
   • Query functions (getNodeDetail, queryNodes, calculateStats)
   • Helper functions
   • Serialization/deserialization

3. example-graph-state.ts (280 lines)
   • Complete example state with 8 nodes, 2 clusters, 6 links
   • Example WebSocket event sequence
   • Serialized state format

4. GRAPH_LIBRARY_RECOMMENDATIONS.md
   • Library comparison (React Flow, D3, Cytoscape, Sigma)
   • Integration examples
   • Performance optimization techniques
   • WebSocket integration

5. IMPLEMENTATION_GUIDE.md
   • Complete React components
   • D3.js setup
   • WebSocket integration
   • CSS utilities

6. DATA_STRUCTURES_DESIGN_SUMMARY.md
   • Complete design overview
   • Detailed pseudo-code
   • Performance analysis
   • Usage examples

7. QUICK_REFERENCE.md
   • Quick lookup guide
   • Common operations
   • Complexity summary

8. ARCHITECTURE_DIAGRAM.txt (this file)
   • Visual architecture overview
   • Data flow diagrams
   • Performance tables

================================================================================
NEXT STEPS
================================================================================

1. Install dependencies:
   npm install reactflow d3-force
   npm install --save-dev @types/d3-force

2. Copy TypeScript files to your project:
   cp graph-data-structures.ts src/types/
   cp graph-state-management.ts src/lib/

3. Implement React component (see IMPLEMENTATION_GUIDE.md)

4. Connect WebSocket to your backend

5. Test with example data (example-graph-state.ts)

================================================================================
